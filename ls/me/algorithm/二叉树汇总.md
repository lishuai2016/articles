# 二叉树

[二叉查找树--插入、删除、查找](http://www.cnblogs.com/aiyelinglong/archive/2012/03/27/2419972.html)
















二叉树的基本概念性质

二叉树的层和深度可以理解为一个定义，根节点的深度为1，及第一层。
节点的度：有一个子节点度数为1，两个子节点度数为2，没有子节点度数为0

简单概述一下二叉树：二叉树是一种很有用的非线性结构，非空二叉树只有一个根结点，每一个结点最多有两棵子树，左子树和右子树，它具有如下几个基本性质：
性质1  在二叉树的第K层上，最多有2^(k-1)(k>=1)个结点。
性质2  深度为M的二叉树最多有（2^m）-1个结点。（等比数列的计算公式）

性质3  在任意一颗二叉树中，度为0的结点（即叶子）总是比度为2的结点多一个。

证明：如果n0表示度为0（即叶子结点）的结点数，用n1表示度为1的结点数，n2表示度为2的结点数，n表示整个完全二叉树的结点总数，则有n=n0+n1+n2，根据二叉树和树的性质，可知n=n1+2xn2+1（所有结点的度数之和加1等于结点总数），根据两个等式可知n0+n1+n2=n1+2xn2+1，即n2=n0-1，也即n0=n2+1。

性质4 具有n个结点的二叉树，其深度至少为[log以2为底的n]+1。

满二叉树：除最后一层外，每一层上的所有结点都有两个子结点。
完全二叉树：除最后一层外，每一层上的结点数均达到最大值；最后一层上只缺少右边的若干结点。

性质5 具有n个结点的完全二叉树的深度[log以2为底的n]+1。

证明：根据性质2，深度为k的二叉树，最多有2^k-1个结点，且完全二叉树的定义是与同深度的满二叉树前边的编号相同，即它们的结点总数n位于k层和k-1层的满二叉树容量之间，即2^(k-1)-1< n <=2^k-1之间，或2^(k-1) <= n <2^k，两边同时取对数得，k-1<=log2(n)<k，又因层数为整数，故log2(n)=k-1，即k=log2(n)+1。

二叉树通常采用链式存储结构，除非是满二叉树或完全二叉树适合用顺序存储。

性质6：对具有n个结点的完全二叉树，如果按照从上至下和从左至右的顺序对二叉树的所有结点从1开始编号，则对于任意的序号为i的结点有：

如果i>1，那么序号为i的结点的双亲结点序号为i/2；

如果i=1，那么序号为i的结点为根节点，无双亲结点；

如果2i<=n，那么序号为i的结点的左孩子结点序号为2i；

如果2i>n，那么序号为i的结点无左孩子；

如果2i+1<=n，那么序号为i的结点右孩子序号为2i+1；

如果2i+1>n，那么序号为i的结点无右孩子。



性质7：给定N个节点，能构成h(N)种不同的二叉树；h(N)为卡特兰数的第N项。h(n)=C(n,2*n)/(n+1)。（？？？）
有（2n)!/((n+1)!n!)种不同的二叉树





ALV树

AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树

平衡二叉树（Balanced Binary Tree）
平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。


AVL树本质上还是一棵二叉搜索树，它的特点是：

1.本身首先是一棵二叉搜索树。

2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。

也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。







常见二叉树分类：
Full Binary Tree (满二叉树)
Complete Binary Tree (完全二叉树)
Balanced Binary Tree (二叉平衡树)
Binary Search Tree (二叉搜索树)
AVL Tree (自平衡二叉搜索树)

- 二叉树搜索：对于所有节点，顺序是：left children <= current node <= right children；
- 平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；



- 完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；（要求最高）
- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；
- 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。


http://www.cnblogs.com/aiyelinglong/archive/2012/03/27/2419972.html  二茬搜索树？？？

红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的

http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html

排序二叉树虽然可以快速检索，但在最坏的情况下：如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很差。
为了改变排序二叉树存在的不足，Rudolf Bayer 与 1972 年发明了另一种改进后的排序二叉树：红黑树，他将这种排序二叉树称为“对称二叉 B 树”，而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出。
红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型地，JDK 提供的集合类 TreeMap 本身就是一个红黑树的实现。
红黑树在原有的排序二叉树增加了如下几个要求：
Java 实现的红黑树上面的性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。

	* 性质 1：每个节点要么是红色，要么是黑色。
	* 性质 2：根节点永远是黑色的。
	* 性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。
	* 性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）
	* 性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

Java 中实现的红黑树可能有如图 6 所示结构：
图 6. Java 红黑树的示意备注：本文中所有关于红黑树中的示意图采用白色代表红色。黑色节点还是采用了黑色表示。
根据性质 5：红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度（black-height）”。
性质 4 则保证了从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍。假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 - 黑节点 - 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 - 红节点 - 黑节点 - 红节点 - 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，红黑树中最长路径就是一条红黑交替的路径。
红黑树和平衡二叉树红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。
由此我们可以得出结论：对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。
提示：排序二叉树的深度直接影响了检索的性能，正如前面指出，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。
红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。
由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。
但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。





2、二叉树的镜像










3、二叉排序树（Binary Sort Tree，二叉查找树，二叉搜索树）


口述用Java代码去实现利用二叉排序树去排一个无序的一维数组

把数组的第一个元素当做根，然后开始从第二个元素开始插入建树，首先和根节点比较大于还是小于，要是小于说明插入左子树，这时判断左子树是否存在，不存在建立一个节点，然后让根节点的左指针指向它，要是左子树存在，递归；同理插入右子树。

有序数组建立二叉搜索树思路：
首先用数组的中间元素作为根建立二叉树，然后递归简历左子树，右子树。


- void buildTree(Bitree &T,int a[],int begin,int end)//建立二叉排序树
- {
-     if(begin>end)//递归的出口
-                  return;
-     int mid = (begin+end)/2;//中间元素的下标
-     if(T==NULL)//为当前树的根节点申请空间
-     {
-                T = (Node *)malloc(sizeof(Node));
-                T->data = a[mid];//赋值
-            T->left = NULL;//左右子树也要置为NULL
-            T->right = NULL;
-     }
-     cout<<a[mid]<<" ";//下面2行为了方便看建立的过程
-     Sleep(1000);
-     buildTree(T->left,a,begin,mid-1);//递归建立左子树
-     buildTree(T->right,a,mid+1,end);//递归建立右子树
-
- }


     二叉排序树又叫二叉查找树，英文名称是：Binary Sort Tree.  BST的定义就不详细说了，我用一句话概括：左 < 中 < 右。 根据这个原理，我们可以推断：BST的中序遍历必定是严格递增的。

[二叉排序树（Binary Sort Tree，二叉查找树，二叉搜索树）--【算法导论】](https://blog.csdn.net/xjm199/article/details/20003045)



给定一棵树，同时给出树中的两个结点(n1和n2)，求它们的最低公共祖先。也就是常见的LCA(Lowest Common Ancestor )问题。

方法一
下面是一个简单的复杂度为 O(n) 的算法，解决LCA问题
1) 找到从根到n1的路径，并存储在一个向量或数组中。
2)找到从根到n2的路径，并存储在一个向量或数组中。
3) 遍历这两条路径，直到遇到一个不同的节点，则前面的那个即为最低公共祖先.


第二种方法(只遍历一次)
上面的方法虽然是O(n)，但是操作依然繁琐了一点，并且需要额外的空间来存储路径。其实可以只遍历一次，利用递归的巧妙之处。学好二叉树，其实就是学好递归。

从root开始遍历，如果n1和n2中的任一个和root匹配，那么root就是LCA。 如果都不匹配，则分别递归左、右子树，如果有一个 key（n1或n2）出现在左子树，并且另一个key(n1或n2)出现在右子树，则root就是LCA.  如果两个key都出现在左子树，则说明LCA在左子树中，否则在右子树。

给定一棵二叉树的根节点和两个任意节点，返回这两个节点之间的最短路径

深度优先标记

复杂度

时间 O(h) 空间 O(h) 递归栈空间

思路

两个节点之间的最短路径一定会经过两个节点的最小公共祖先，所以我们可以用LCA的解法。不同于LCA的是，我们返回不只是标记，而要返回从目标结点递归回当前节点的路径。当遇到最小公共祖先的时候便合并路径。需要注意的是，我们要单独处理目标节点自身是最小公共祖先的情况。


public LinkedList<TreeNode> helper(TreeNode n, TreeNode p, TreeNode q){
    if(n == null){
        return null;
    }
   
    LinkedList<TreeNode> left = helper(n.left, p, q);
    LinkedList<TreeNode> right = helper(n.right, p, q);
   
    // 当左右都为空时
    if(left == null && right == null){
        // 如果当前节点是目标节点，开启一条新路径
        if(n == p || n == q){
            LinkedList l = new LinkedList<TreeNode>();
            l.add(n);
            return l;
        } else {
        // 否则标记为空
            return null;
        }
    // 如果左右节点都不为空，说明是最小公共祖先节点，合并两条路径
    } else if(left != null && right != null){
        finalPath.addAll(left);
        finalPath.add(n);
        Collections.reverse(right);
        finalPath.addAll(right);
        return left;
    // 如果当前节点是目标结点，且某一个子树不为空时，说明最小公共祖先是节点自身
    } else if (left != null){
        left.add(n);
        if(n == p || n == q){
            finalPath.addAll(left);
        }
        return left;
    } else {
        right.add(n);
        if(n == p || n == q){
            finalPath.addAll(right);
        }
        return right;
    }
}

打印根节点到叶子节点的路径

Root To Leaf Binary Tree Paths

思路

简单的二叉树遍历，遍历的过程中记录之前的路径，一旦遍历到叶子节点便将该路径加入结果中。

代码

public class Solution {
   
    List<String> res = new ArrayList<String>();
   
    public List<String> binaryTreePaths(TreeNode root) {
        if(root != null) findPaths(root,String.valueOf(root.val));
        return res;
    }
   
    private void findPaths(TreeNode n, String path){
        if(n.left == null && n.right == null) res.add(path);
        if(n.left != null) findPaths(n.left, path+"->"+n.left.val);
        if(n.right != null) findPaths(n.right, path+"->"+n.right.val);
    }
}


1、求一个二叉树的节点个数

/**
 *
 */
package tree1;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;





/**
 * @author lishuai
 * @data 2016-12-30 下午2:50:33
 */

public class NodeNum {

    /**
     * @author lishuai
     * @data 2016-12-30 下午2:50:33
     * @param args
     */
    /*
    1 
   / \ 
  2   3 
 / \   \ 
4   5   6     
*/ 
    public static void main(String[] args) {
        TreeNode r1 = new TreeNode(1);
        TreeNode r2 = new TreeNode(2);
        TreeNode r3 = new TreeNode(3);
        TreeNode r4 = new TreeNode(4);
        TreeNode r5 = new TreeNode(5);
        TreeNode r6 = new TreeNode(6);
        r1.left = r2;
        r1.right = r3;
        r2.left = r4;
        r2.right = r5;
        r3.right = r6;


//        System.out.println( getNodeNumRec(r1));
//        System.out.println( getNodeNum(r1));
        System.out.println( getNodeNum3(r1));
    }
    //1递归
    public static int getNodeNumRec(TreeNode root) {
        if (root == null) return 0;
        return getNodeNumRec(root.left) + getNodeNumRec(root.right) + 1;
    }
    //2迭代 原理同先序遍历，借助一个栈，时间复杂度N
    public static int getNodeNum(TreeNode root) {
        int res = 0;
        if (root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            res++;
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
        return res;
    }

     /**
     *  求二叉树中的节点个数迭代解法O(n)：基本思想同LevelOrderTraversal，
     *  即用一个Queue，在Java里面可以用LinkedList来模拟 
     */ 
    //3 迭代 借助队列实现
    public static int getNodeNum3(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(root);

        int cnt = 0;
        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            if (node.left != null) {
                q.offer(node.left);
            }

            if (node.right != null) {
                q.offer(node.right);
            }

            cnt++;
        }

        return cnt;
    }
}




二叉树的遍历（先序，中序，后序，层序）
1、先序遍历（递归、迭代、分治）

递归实现：
public ArrayList<Integer> preorderTraversal3(TreeNode root) {
             ArrayList<Integer> result = new ArrayList<Integer>();
             traverse(root, result);
             return result;
         }
         // 把root为跟的preorder加入result里面
         private void traverse(TreeNode root, ArrayList<Integer> result) {
             if (root == null) {
                 return;
             }

             result.add(root.val);
             traverse(root.left, result);
             traverse(root.right, result);
         }
迭代实现：
public List<Integer> preorderTraversal2(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> preorder = new ArrayList<Integer>();

        if (root == null) {
            return preorder;
        }

        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            preorder.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }

        return preorder;
    }
分治实现：
public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        // null or leaf
        if (root == null) {
            return result;
        }

        // Divide
        ArrayList<Integer> left = preorderTraversal(root.left);
        ArrayList<Integer> right = preorderTraversal(root.right);

        // Conquer
        result.add(root.val);
        result.addAll(left);
        result.addAll(right);
        return result;

2、中序（迭代、递归）

迭代：
public List<Integer> inorderTraversal2(TreeNode root) {
         List<Integer> list = new ArrayList<Integer>();

         Stack<TreeNode> stack = new Stack<TreeNode>();
         TreeNode cur = root;//可以直接使用root

         while(cur != null || !stack.empty()){
             while(cur != null){
                 stack.add(cur);
                 cur = cur.left;
             }
             cur = stack.pop();
             list.add(cur.val);
             cur = cur.right;
         }

         return list;
     }



递归：
 public static List<Integer> inorderTraversal0(TreeNode root) {
     if (root == null) return res;
     inOrder(root);
        return res;
    }
    public static void inOrder(TreeNode root) {     //中根遍历
          if(root != null) {
                inOrder(root.left);
                res.add(root.val);
                System.out.print(root.val + "--");
                inOrder(root.right);
          }
     }

3、后序（迭代、递归）
递归：
public ArrayList<Integer> postorderTraversal(TreeNode root) {
         ArrayList<Integer> result = new ArrayList<Integer>();

         if (root == null) {
             return result;
         }

         result.addAll(postorderTraversal(root.left));
         result.addAll(postorderTraversal(root.right));
         result.add(root.val);

         return result;
     }

迭代：
List<Integer> results = new ArrayList<Integer>();
          Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
          while (!stack.isEmpty() || root != null) {
              if (root != null) {
                   stack.push(root);
                   results.add(root.val);
                   root = root.right;
              } else {
                   root = stack.pop().left;
              }
          }
          Collections.reverse(results);
          return results;
或者下面的这种写法

Stack<TreeNode> stack = new Stack<TreeNode>();
        while (!stack.empty() || root != null) {
            while (root != null) {
                stack.push(root);
                res.add(root.val);
                root = root.right;
            }
            root = stack.pop().left;
        }
        Collections.reverse(res);


4、层序（迭代、递归）
// version 1: BFSpublic class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList result = new ArrayList();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode head = queue.poll();
                level.add(head.val);
                if (head.left != null) {
                    queue.offer(head.left);
                }
                if (head.right != null) {
                    queue.offer(head.right);
                }
            }
            result.add(level);
        }

        return result;
    }}


// version 2:  DFSpublic class Solution {
    /**
    * @param root: The root of binary tree.
    * @return: Level order a list of lists of integer
    */
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
       
        if (root == null) {
            return results;
        }
       
        int maxLevel = 0;
        while (true) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            dfs(root, level, 0, maxLevel);
            if (level.size() == 0) {
                break;
            }
           
            results.add(level);
            maxLevel++;
        }
       
        return results;
    }
   
    private void dfs(TreeNode root,
                    ArrayList<Integer> level,
                    int curtLevel,
                    int maxLevel) {
        if (root == null || curtLevel > maxLevel) {
            return;
        }
       
        if (curtLevel == maxLevel) {
            level.add(root.val);
            return;
        }
       
        dfs(root.left, level, curtLevel + 1, maxLevel);
        dfs(root.right, level, curtLevel + 1, maxLevel);
    }}

/** 递归实现前序遍历 */
protected static void preorder(Node p) {
   if (p != null) {
    visit(p);
    preorder(p.getLeft());
    preorder(p.getRight());
   }
}

/** 递归实现中序遍历 */
protected static void inorder(Node p) {
   if (p != null) {
    inorder(p.getLeft());
    visit(p);
    inorder(p.getRight());
   }
}

/** 递归实现后序遍历 */
protected static void postorder(Node p) {
   if (p != null) {
    postorder(p.getLeft());
    postorder(p.getRight());
    visit(p);
   }
}

/** 非递归实现前序遍历 */
protected static void iterativePreorder(Node p) {
   Stack<Node> stack = new Stack<Node>();
   if (p != null) {
    stack.push(p);
    while (!stack.empty()) {
     p = stack.pop();
     visit(p);
     if (p.getRight() != null)
      stack.push(p.getRight());
     if (p.getLeft() != null)
      stack.push(p.getLeft());
    }
   }
}

/** 非递归实现前序遍历2 */
protected static void iterativePreorder2(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {//压入所有的左节点，压入前访问它
     visit(node);
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {//
     node = stack.pop();
     node = node.getRight();
    }
   }
}

/** 非递归实现后序遍历 */
protected static void iterativePostorder(Node p) {
   Node q = p;
   Stack<Node> stack = new Stack<Node>();
   while (p != null) {
    // 左子树入栈
    for (; p.getLeft() != null; p = p.getLeft())
     stack.push(p);
    // 当前节点无右子或右子已经输出
    while (p != null && (p.getRight() == null || p.getRight() == q)) {
     visit(p);
     q = p;// 记录上一个已输出节点
     if (stack.empty())
      return;
     p = stack.pop();
    }
    // 处理右子
    stack.push(p);
    p = p.getRight();
   }
}

/** 非递归实现后序遍历 双栈法 */
protected static void iterativePostorder2(Node p) {
   Stack<Node> lstack = new Stack<Node>();
   Stack<Node> rstack = new Stack<Node>();
   Node node = p, right;
   do {
    while (node != null) {
     right = node.getRight();
     lstack.push(node);
     rstack.push(right);
     node = node.getLeft();
    }
    node = lstack.pop();
    right = rstack.pop();
    if (right == null) {
     visit(node);
    } else {
     lstack.push(node);
     rstack.push(null);
    }
    node = right;
   } while (lstack.size() > 0 || rstack.size() > 0);
}

/** 非递归实现后序遍历 单栈法*/
protected static void iterativePostorder3(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p, prev = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {
     Node temp = stack.peek().getRight();
     if (temp == null || temp == prev) {
      node = stack.pop();
      visit(node);
      prev = node;
      node = null;
     } else {
      node = temp;
     }
    }

   }
}

/** 非递归实现后序遍历4 双栈法*/
protected static void iterativePostorder4(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Stack<Node> temp = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     temp.push(node);
     stack.push(node);
     node = node.getRight();
    }
    if (stack.size() > 0) {
     node = stack.pop();
     node = node.getLeft();
    }
   }
   while (temp.size() > 0) {
    node = temp.pop();
    visit(node);
   }
}

/** 非递归实现中序遍历 */
protected static void iterativeInorder(Node p) {
   Stack<Node> stack = new Stack<Node>();
   while (p != null) {
    while (p != null) {
     if (p.getRight() != null)
      stack.push(p.getRight());// 当前节点右子入栈
     stack.push(p);// 当前节点入栈
     p = p.getLeft();
    }
    p = stack.pop();
    while (!stack.empty() && p.getRight() == null) {
     visit(p);
     p = stack.pop();
    }
    visit(p);
    if (!stack.empty())
     p = stack.pop();
    else
     p = null;
   }
}

/** 非递归实现中序遍历2 */
protected static void iterativeInorder2(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {
     node = stack.pop();
     visit(node);
     node = node.getRight();
    }
   }
/** 递归实现前序遍历 */
protected static void preorder(Node p) {
   if (p != null) {
    visit(p);
    preorder(p.getLeft());
    preorder(p.getRight());
   }
}

/** 递归实现中序遍历 */
protected static void inorder(Node p) {
   if (p != null) {
    inorder(p.getLeft());
    visit(p);
    inorder(p.getRight());
   }
}

/** 递归实现后序遍历 */
protected static void postorder(Node p) {
   if (p != null) {
    postorder(p.getLeft());
    postorder(p.getRight());
    visit(p);
   }
}

/** 非递归实现前序遍历 */
protected static void iterativePreorder(Node p) {
   Stack<Node> stack = new Stack<Node>();
   if (p != null) {
    stack.push(p);
    while (!stack.empty()) {
     p = stack.pop();
     visit(p);
     if (p.getRight() != null)
      stack.push(p.getRight());
     if (p.getLeft() != null)
      stack.push(p.getLeft());
    }
   }
}

/** 非递归实现前序遍历2 */
protected static void iterativePreorder2(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {//压入所有的左节点，压入前访问它
     visit(node);
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {//
     node = stack.pop();
     node = node.getRight();
    }
   }
}

/** 非递归实现后序遍历 */
protected static void iterativePostorder(Node p) {
   Node q = p;
   Stack<Node> stack = new Stack<Node>();
   while (p != null) {
    // 左子树入栈
    for (; p.getLeft() != null; p = p.getLeft())
     stack.push(p);
    // 当前节点无右子或右子已经输出
    while (p != null && (p.getRight() == null || p.getRight() == q)) {
     visit(p);
     q = p;// 记录上一个已输出节点
     if (stack.empty())
      return;
     p = stack.pop();
    }
    // 处理右子
    stack.push(p);
    p = p.getRight();
   }
}

/** 非递归实现后序遍历 双栈法 */
protected static void iterativePostorder2(Node p) {
   Stack<Node> lstack = new Stack<Node>();
   Stack<Node> rstack = new Stack<Node>();
   Node node = p, right;
   do {
    while (node != null) {
     right = node.getRight();
     lstack.push(node);
     rstack.push(right);
     node = node.getLeft();
    }
    node = lstack.pop();
    right = rstack.pop();
    if (right == null) {
     visit(node);
    } else {
     lstack.push(node);
     rstack.push(null);
    }
    node = right;
   } while (lstack.size() > 0 || rstack.size() > 0);
}

/** 非递归实现后序遍历 单栈法*/
protected static void iterativePostorder3(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p, prev = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {
     Node temp = stack.peek().getRight();
     if (temp == null || temp == prev) {
      node = stack.pop();
      visit(node);
      prev = node;
      node = null;
     } else {
      node = temp;
     }
    }

   }
}

/** 非递归实现后序遍历4 双栈法*/
protected static void iterativePostorder4(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Stack<Node> temp = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     temp.push(node);
     stack.push(node);
     node = node.getRight();
    }
    if (stack.size() > 0) {
     node = stack.pop();
     node = node.getLeft();
    }
   }
   while (temp.size() > 0) {
    node = temp.pop();
    visit(node);
   }
}

/** 非递归实现中序遍历 */
protected static void iterativeInorder(Node p) {
   Stack<Node> stack = new Stack<Node>();
   while (p != null) {
    while (p != null) {
     if (p.getRight() != null)
      stack.push(p.getRight());// 当前节点右子入栈
     stack.push(p);// 当前节点入栈
     p = p.getLeft();
    }
    p = stack.pop();
    while (!stack.empty() && p.getRight() == null) {
     visit(p);
     p = stack.pop();
    }
    visit(p);
    if (!stack.empty())
     p = stack.pop();
    else
     p = null;
   }
}

/** 非递归实现中序遍历2 */
protected static void iterativeInorder2(Node p) {
   Stack<Node> stack = new Stack<Node>();
   Node node = p;
   while (node != null || stack.size() > 0) {
    while (node != null) {
     stack.push(node);
     node = node.getLeft();
    }
    if (stack.size() > 0) {
     node = stack.pop();
     visit(node);
     node = node.getRight();
    }
   }
}
}



二叉树常见操作以及概念总结

如何确定一个节点root是叶子节点
root.left == null && root.right == null

Binary Tree Preorder Traversal先序遍历（递归实现和非递归实现）
非递归思路：借助于一个栈
Version 0: Non-Recursion (Recommend)/**
* Definition for binary tree
* public class TreeNode {
*    int val;
*    TreeNode left;
*    TreeNode right;
*    TreeNode(int x) { val = x; }
* }
*/public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> preorder = new ArrayList<Integer>();
       
        if (root == null) {
            return preorder;
        }
       
        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            preorder.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
       
        return preorder;
    }}

//Version 1: Traverse
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        traverse(root, result);
        return result;
    }
    // 把root为跟的preorder加入result里面
    private void traverse(TreeNode root, ArrayList<Integer> result) {
        if (root == null) {
            return;
        }

        result.add(root.val);
        traverse(root.left, result);
        traverse(root.right, result);
    }}

中序遍历
迭代：
public List<Integer> inorderTraversal2(TreeNode root) {
         List<Integer> list = new ArrayList<Integer>();

         Stack<TreeNode> stack = new Stack<TreeNode>();
         TreeNode cur = root;//可以直接使用root

         while(cur != null || !stack.empty()){
             while(cur != null){
                 stack.add(cur);
                 cur = cur.left;
             }
             cur = stack.pop();
             list.add(cur.val);
             cur = cur.right;
         }

         return list;
     }

递归：
 public static List<Integer> inorderTraversal0(TreeNode root) {
     if (root == null) return res;
     inOrder(root);
        return res;
    }
    public static void inOrder(TreeNode root) {     //中根遍历
          if(root != null) {
                inOrder(root.left);
                res.add(root.val);
                System.out.print(root.val + "--");
                inOrder(root.right);
          }
     }

后续遍历
//Recursivepublic ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();

    if (root == null) {
        return result;
    }

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result; 
}
迭代实现思路1：
//Iterative
public ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode prev = null; // previously traversed node
    TreeNode curr = root;

    if (root == null) {
        return result;
    }

    stack.push(root);
    while (!stack.empty()) {
        curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { // traverse up the tree from the left
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else { // traverse up the tree from the right
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }

    return result;}

迭代实现思路2：在中序遍历的基础上改进，先根节点然后右节点最后左节点，最后整体翻转一次即可
Stack<TreeNode> stack = new Stack<TreeNode>();
        while (!stack.empty() || root != null) {
            while (root != null) {
                stack.push(root);
                res.add(root.val);
                root = root.right;
            }
            root = stack.pop().left;
        }
        Collections.reverse(res);



层序遍历
思路：非递归，借助一个队列实现，每一层通过当前队列的大小来实现
// version 1: BFS
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList result = new ArrayList();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode head = queue.poll();
                level.add(head.val);
                if (head.left != null) {
                    queue.offer(head.left);
                }
                if (head.right != null) {
                    queue.offer(head.right);
                }
            }
            result.add(level);
        }

        return result;
    }}
思路：dfs，一层一层的计算

// version 2:  DFS
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
       
        if (root == null) {
            return results;
        }
       
        int maxLevel = 0;
        while (true) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            dfs(root, level, 0, maxLevel);
            if (level.size() == 0) {
                break;
            }
           
            results.add(level);
            maxLevel++;
        }
       
        return results;
    }
   
    private void dfs(TreeNode root,
                    ArrayList<Integer> level,
                    int curtLevel,
                    int maxLevel) {
        if (root == null || curtLevel > maxLevel) {
            return;
        }
       
        if (curtLevel == maxLevel) {
            level.add(root.val);
            return;
        }
       
        dfs(root.left, level, curtLevel + 1, maxLevel);
        dfs(root.right, level, curtLevel + 1, maxLevel);
    }}


1、树的最小深度（到叶子节点）
二叉树的最小深度为根节点到最近叶子节点的距离。
思路：当某个节点为null时返回最大整数（这样处理主要是为了处理只有一个子节点的节点），当判断是叶子节点时返回1，然后要是非叶子节点递归求他们的最小深度然后加1
public int minDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return getMin(root);
    }
    public int getMin(TreeNode root) {
        if (root == null) {
            return Integer.MAX_VALUE;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        return Math.min(getMin(root.left), getMin(root.right)) + 1;
    }
2、树的最大深度
二叉树的深度为根节点到最远叶子节点的距离。

思路：当遍历的节点为null的时候返回0，然后递归求左右节点的最大深度取较大的那个然后加1
public int maxDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }


3、二叉树中的最大节点

思路：判断根节点和他的左右子节点哪个大，左右节点递归处理即可
public TreeNode maxNode(TreeNode root) {
        // Write your code here
        if (root == null) {
            return null;
        }
        TreeNode maxNode = root;
        TreeNode maxLeftNode = maxNode(root.left);
        TreeNode maxRightNode = maxNode(root.right);
        if (maxLeftNode != null && maxRightNode != null) {
            TreeNode temp = maxLeftNode.val > maxRightNode.val ? maxLeftNode : maxRightNode;
            return root.val > temp.val ? root : temp;
        } else if (maxLeftNode != null && maxRightNode == null) {
            return root.val > maxLeftNode.val ? root : maxLeftNode;
        } else if (maxLeftNode == null && maxRightNode != null) {
            return root.val > maxRightNode.val ? root : maxRightNode;
        } else {
            return root;
        }
    }
法二：
public TreeNode maxNode(TreeNode root) {
        // Write your code here
        if (root == null)
            return root;

        TreeNode left = maxNode(root.left);
        TreeNode right = maxNode(root.right);
        return max(root, max(left, right));
    }

    TreeNode max(TreeNode a, TreeNode b) {
        if (a == null)
            return b;
        if (b == null)
            return a;
        if (a.val > b.val) {
            return a;
        }
        return b;
    }
4、二叉树的所有路径
给一棵二叉树，找出从根节点到叶子节点的所有路径

思路：通过判断一个节点是否为叶子节点，不是的话递归，是的话添加到list中
public List<String> binaryTreePaths(TreeNode root) {
        // Write your code here
        List<String> res = new ArrayList<String>();
        if (root == null) {
            return res;
        }
        path(root, root.val + "", res);
        return res;
    }
    public void path(TreeNode root, String path, List<String> res) {
        if (root != null) {
            if (root.left != null && root.right != null) {
                path(root.left, path + "->" + root.left.val, res);
                path(root.right, path + "->" + root.right.val, res);
            } else if (root.left != null && root.right == null) {
                path(root.left, path + "->" + root.left.val, res);
            } else if (root.left == null && root.right != null) {
                path(root.right,path + "->" + root.right.val, res);
            } else {
                res.add(path);
            }
        }
    }
5、深度复制一个二叉树。
给定一个二叉树，返回一个他的 克隆品 。
//思路：判断一个节点是不是null，不是的话就新建一个节点，新建节点的左右指向原节点左右节点递归的结果，返回新建节点
public TreeNode cloneTree(TreeNode root) {
        // Write your code here
        if (root == null) {
            return null;
        }
        TreeNode clone_tree = new TreeNode(root.val);
        clone_tree.left = cloneTree(root.left);
        clone_tree.right = cloneTree(root.right);
        return clone_tree;
    }
6、给一个排序数组（从小到大），将其转换为一棵高度最小的排序二叉树。（平衡二叉树）

思路：把中间元素作为根节点，然后递归实现（注意点递归时后面的界限为数组的长度）
public TreeNode sortedArrayToBST(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return null;
        }
        return bst(A, 0, A.length);
    }
    public TreeNode bst(int[] a, int start, int end) {
        if (start < end) {
            int mid = start + (end - start) / 2;
            TreeNode node = new TreeNode(a[mid]);
            node.left = bst(a, start, mid);
            node.right = bst(a, mid + 1, end);
            return node;
        } else {
            return null;
        }
    }

给出一个所有元素以升序排序的单链表，将它转换成一棵高度平衡的二分查找树
public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) { 
        // write your code here
        if (head == null) {
            return null;
        }
        return  sort(head, null);
    }

    public TreeNode sort(ListNode head, ListNode tail) {
        if (head == tail) {
            return null;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != tail && fast.next != tail) {
            fast = fast.next.next;
            slow = slow.next;
        }
        TreeNode node = new TreeNode(slow.val);
        node.left = sort(head, slow);
        node.right = sort(slow.next, tail);
        return node;
    }
}



7、将二叉树拆成链表
将一棵二叉树按照前序遍历拆解成为一个假链表。所谓的假链表是说，用二叉树的 right 指针，来表示链表中的 next 指针。

思路：使用一个指针变量来指向当前转化到哪里，借助前序遍历修改指针的指向，需要注意的点是左指针制为null，此外在修改左子节点是先保存右子节点到一个临时变量
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public TreeNode last = null;
    public void flatten(TreeNode root) {
        // write your code here
        if (root == null) {
            return;
        }
        if (last != null) {
            last.left = null;
            last.right = root;
        }
        last = root;
        TreeNode right = root.right;
        flatten(root.left);
        flatten(right);
    }
}
8、 等价二叉树
检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。

思路：首先判断根节点是否一样，然后在判断左子节点和左子节点，右子节点和右子节点
 public boolean isIdentical(TreeNode a, TreeNode b) {
        // Write your code here
        if (a != null && b != null && a.val == b.val) {
            return isIdentical(a.left, b.left) && isIdentical(a.right, b.right);
        } else if (a == null && b == null) {
            return true;
        } else {
            return false;
        }
    }
9、翻转一棵二叉树

思路：类比交换连个数，然后递归左右子树
public void invertBinaryTree(TreeNode root) {
        // write your code here
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertBinaryTree(root.left);
        invertBinaryTree(root.right);
    }
10、二叉树的右侧视图
For example:
Given the following binary tree,

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---


You should return [1, 3, 4].
思路：深度优先遍历，每一层用map存最右边的节点值（同一层的左节点值会被右节点值覆盖掉），然后在map中每一层去处一个值即可
public class Solution {
    private void dfs(HashMap<Integer, Integer> depthToValue, TreeNode node, int depth) {
        if (node == null) {
            return;
        }
       
        depthToValue.put(depth, node.val);
        dfs(depthToValue, node.left, depth + 1);
        dfs(depthToValue, node.right, depth + 1);
    }
   
    public List<Integer> rightSideView(TreeNode root) {
        HashMap<Integer, Integer> depthToValue = new HashMap<Integer, Integer>();
        dfs(depthToValue, root, 1);
       
        int depth = 1;
        List<Integer> result = new ArrayList<Integer>();
        while (depthToValue.containsKey(depth)) {
            result.add(depthToValue.get(depth));
            depth++;
        }
        return result;
    }}
11、二叉搜索树中添加一个元素（递归和非递归），插入的元素一定是叶子节点？？

思路非递归：使用一个指针指向要插入节点，然后判断插入左还是右边即可
public class Solution {
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        TreeNode tmp = root;
        TreeNode last = null;
        while (tmp != null) {
            last = tmp;
            if (tmp.val > node.val) {
                tmp = tmp.left;
            } else {
                tmp = tmp.right;
            }
        }
        if (last != null) {
            if (last.val > node.val) {
                last.left = node;
            } else {
                last.right = node;
            }
        }
        return root;
    }}


思路：递归实现，判断插入的值和根节点的大小
 public class Solution {
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        if (root.val > node.val) {
            root.left = insertNode(root.left, node);
        } else {
            root.right = insertNode(root.right, node);
        }
        return root;
    }}

二叉搜索树中删除一个节点（有待处理）
给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是二叉查找树。

思路：
public class Solution {
    /**
    * @param root: The root of the binary search tree.
    * @param value: Remove the node with given value.
    * @return: The root of the binary search tree after removal.
    */
    public TreeNode removeNode(TreeNode root, int value) {
        TreeNode dummy = new TreeNode(0);
        dummy.left = root;
       
        TreeNode parent = findNode(dummy, root, value);
        TreeNode node;
        if (parent.left != null && parent.left.val == value) {
            node = parent.left;
        } else if (parent.right != null && parent.right.val == value) {
            node = parent.right;
        } else {
     //直接返回，没有找到节点
            return dummy.left;
        }
       
        deleteNode(parent, node);
       
        return dummy.left;
    }
    //获取指定节点的父节点
    private TreeNode findNode(TreeNode parent, TreeNode node, int value) {
        if (node == null) {
            return parent;
        }
       
        if (node.val == value) {
            return parent;
        }
        if (value < node.val) {
            return findNode(node, node.left, value);
        } else {
            return findNode(node, node.right, value);
        }
    }
   
  private static void deleteNode(TreeNode parent, TreeNode node) {
  //只有左节点，或者叶子节点
  if (node.right == null) {
  if (parent.left == node) {
  parent.left = node.left;
  } else {
  parent.right = node.left;
  }
  } else {
  //找删除节点的后继节点，该节点只有右子树
  TreeNode temp = node.right;
  TreeNode father = node;

  while (temp.left != null) {
  father = temp;
  temp = temp.left;
  }

  if (father.left == temp) {
  father.left = temp.right;
  } else {
  father.right = temp.right;
  }

  //被删除节点的父节点指向删除节点的后继节点，后继节点指向被删除节点的左右节点
  if (parent.left == node) {
  parent.left = temp;
  } else {
  parent.right = temp;
  }

  temp.left = node.left;
  temp.right = node.right;
  }
  }


12、二叉树的序列化和反序列化
序列化：思路借助一个数组，把树的所有元素装入数组，然后清除数组最后都是null的元素，然后遍历数组，为null的用一个字符#代替
反序列化：思路，首先把元素放入第一个数组，然后遍历；把生成的节点放入第二个数组，好用它来指向它的子节点，借助一个Boolean类型的变量来判断是左子节点还是右子节点，要是右子节点，第二个数组的下标后移一位

class Solution {
   
    public String serialize(TreeNode root) {
        if (root == null) {
            return "{}";
        }

        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        queue.add(root);

        for (int i = 0; i < queue.size(); i++) {
            TreeNode node = queue.get(i);
            if (node == null) {
                continue;
            }
            queue.add(node.left);
            queue.add(node.right);
        }

        while (queue.get(queue.size() - 1) == null) {
            queue.remove(queue.size() - 1);
        }

        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append(queue.get(0).val);
        for (int i = 1; i < queue.size(); i++) {
            if (queue.get(i) == null) {
                sb.append(",#");
            } else {
                sb.append(",");
                sb.append(queue.get(i).val);
            }
        }
        sb.append("}");
        return sb.toString();
    }
   
   
    public TreeNode deserialize(String data) {
        if (data.equals("{}")) {
            return null;
        }
        String[] vals = data.substring(1, data.length() - 1).split(",");
        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        queue.add(root);
        int index = 0;
        boolean isLeftChild = true;
        for (int i = 1; i < vals.length; i++) {
            if (!vals[i].equals("#")) {
                TreeNode node = new TreeNode(Integer.parseInt(vals[i]));
                if (isLeftChild) {
                    queue.get(index).left = node;
                } else {
                    queue.get(index).right = node;
                }
                queue.add(node);
            }
            if (!isLeftChild) {
                index++;
            }
            isLeftChild = !isLeftChild;
        }
        return root;
    }}
13、设计实现一个带有下列属性的二叉查找树的迭代器：

	* 元素按照递增的顺序被访问（比如中序遍历）
	* next()和hasNext()的询问操作要求均摊时间复杂度是O(1)

思路：中序遍历的思想，全局维护一个栈和当前游标

public class BSTIterator {
    private Stack<TreeNode> stack = new Stack<>();
    private TreeNode curt;
   
    // @param root: The root of binary tree.
    public BSTIterator(TreeNode root) {
        curt = root;
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return (curt != null || !stack.isEmpty());
    }
   
    //@return: return next node
    public TreeNode next() {
        while (curt != null) {
            stack.push(curt);
            curt = curt.left;
        }
       
        curt = stack.pop();
        TreeNode node = curt;
        curt = curt.right;
       
        return node;
    }}
14、树的节点个数

- /**
-      * 求二叉树中的节点个数递归解法： O(n)
-      * （1）如果二叉树为空，节点个数为0
-      * （2）如果二叉树不为空，二叉树节点个数 = 左子树节点个数 +
-      *            右子树节点个数 + 1
-      */
-     public static int getNodeNumRec(TreeNode root) {
-         if (root == null) {
-             return 0;
-         } else {
-             return getNodeNumRec(root.left) + getNodeNumRec(root.right) + 1;
-         }
-     }
-
-     /**
-      *  求二叉树中的节点个数迭代解法O(n)：基本思想同LevelOrderTraversal，
-      *  即用一个Queue，在Java里面可以用LinkedList来模拟
-      */
-     public static int getNodeNum(TreeNode root) {
-         if(root == null){
-             return 0;
-         }
-         int count = 1;
-         Queue<TreeNode> queue = new LinkedList<TreeNode>();
-         queue.add(root);
-
-         while(!queue.isEmpty()){
-             TreeNode cur = queue.remove();      // 从队头位置移除
-             if(cur.left != null){           // 如果有左孩子，加到队尾
-                 queue.add(cur.left);
-                 count++;
-             }
-             if(cur.right != null){      // 如果有右孩子，加到队尾
-                 queue.add(cur.right);
-                 count++;
-             }
-         }
-
-         return count;
-     }
15、Binary Tree Maximum Path Sum（没理解法二好一些）
计算树的最长path有2种情况：

1. 通过根的path.

  (1)如果左子树从左树根到任何一个Node的path大于零，可以链到root上

  (2)如果右子树从右树根到任何一个Node的path大于零，可以链到root上

2. 不通过根的path. 这个可以取左子树及右子树的path的最大值。

所以创建一个inner class:

记录2个值：

1. 本树的最大path。

2. 本树从根节点出发到任何一个节点的最大path.

Given a binary tree, find the maximum path sum. 
The path may start and end at any node in the tree. 

For example: 
Given the below binary tree, 
  1 
 /  \ 
2   3 
Return 6.
public class Solution {
    private class ResultType {
        // singlePath: 从root往下走到任意点的最大路径，这条路径可以不包含任何点
        // maxPath: 从树中任意到任意点的最大路径，这条路径至少包含一个点
        int singlePath, maxPath;
        ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }

    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(0, Integer.MIN_VALUE);
        }
        // Divide
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // Conquer
        int singlePath = Math.max(left.singlePath, right.singlePath) + root.val;
        singlePath = Math.max(singlePath, 0);

        int maxPath = Math.max(left.maxPath, right.maxPath);
        maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val);

        return new ResultType(singlePath, maxPath);
    }

    public int maxPathSum(TreeNode root) {
        ResultType result = helper(root);
        return result.maxPath;
    }}


// Version 2:// SinglePath也定义为，至少包含一个点。public class Solution {
    /**
    * @param root: The root of binary tree.
    * @return: An integer.
    */
    private class ResultType {
        int singlePath, maxPath;
        ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }

    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(Integer.MIN_VALUE, Integer.MIN_VALUE);
        }
        // Divide
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // Conquer
        int singlePath =
            Math.max(0, Math.max(left.singlePath, right.singlePath)) + root.val;

        int maxPath = Math.max(left.maxPath, right.maxPath);
        maxPath = Math.max(maxPath,
                          Math.max(left.singlePath, 0) +
                          Math.max(right.singlePath, 0) + root.val);

        return new ResultType(singlePath, maxPath);
    }

    public int maxPathSum(TreeNode root) {
        ResultType result = helper(root);
        return result.maxPath;
    }

}
16、给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode A, TreeNode B) {
        // write your code here
        if (root == null || root == A || root == B) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, A, B);
        TreeNode right = lowestCommonAncestor(root.right, A, B);
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        } else {
            return null;
        }
    }

17、判断子树
public boolean isSubtree(TreeNode T1, TreeNode T2) {
        // write your code here
        boolean res = false;
        if (T2 == null) {
            return true;
        }
        if (T1 == null) {
            return false;
        }
        if (T1.val == T2.val) {
            res = tree1HasTree2(T1,T2);
        }
        if(!res) {
            res = isSubtree(T1.left,T2);
        }
        if(!res) {
            res = isSubtree(T1.right,T2);
        }
        return res;
    }
    public boolean tree1HasTree2(TreeNode T1, TreeNode T2) {
        if (T1 == null && T2 == null) {
            return true;
        }
        if (T1 != null && T2 != null && T1.val == T2.val) {
            return tree1HasTree2(T1.left,T2.left) && tree1HasTree2(T1.right,T2.right);
        }
        return false;
    }

18\路径和
public static List<List<Integer>> binaryTreePathSum(TreeNode root, int target) {
             List<List<Integer>> res = new ArrayList<List<Integer>>();
             if (root==null) {
                 return res;
             }
             List<Integer> path = new ArrayList<Integer>();
             path.add(root.value);
             helper(res,path,root,target,root.value);
             return res;
  }


  public static void helper( List<List<Integer>> res,List<Integer> path,TreeNode root,int target,int sum) {
             if (root.left == null && root.right == null && sum == target) {
                 res.add( new ArrayList<Integer>(path));
                 return;
             }
             if (root.left != null) {
                 path.add(root.left.value);
                 helper(res,path,root.left,target,sum + root.left.value);
                 path.remove(path.size() - 1);
             }
             if (root.right != null) {
                 path.add(root.right.value);
                 helper(res,path,root.right,target,sum + root.right.value);
                 path.remove(path.size() - 1);
             }
  }








二叉树常见操作


1、检测二叉树是否平衡
递归判断N*logN

public static boolean isbalance(TreeNode root) {
        //终止条件
        if (root == null) {
            return true;
        }
        if (Math.abs(maxdep(root.left) - maxdep(root.right)) <  1) {
            return isbalance(root.left) && isbalance(root.right);
        }
        return false;


    }
    public static int maxdep(TreeNode root) {
        //终止条件
        if (root == null) {
            return 0;
        }
        return Math.max(maxdep(root.left),maxdep(root.right))+1;
    }

优化：时间复杂度N，空间复杂度H，（H是树的高度）
若子树平衡checkheight返回树的高度，否则返回-1

public static int checkheight(TreeNode root) {
        if (root == null) {
            return 0;//高度为0
        }
        //检查左子树是否平衡
        int leftheight = checkheight(root.left);
        if (leftheight == -1) {
            return -1;//不平衡
        }
        //检查右子树是否平衡
        int rightheight = checkheight(root.right);
        if (rightheight == -1) {
            return -1;//不平衡
        }
        //检查当前节点是否平衡
        int heightdiff = leftheight - rightheight;
        if (Math.abs(heightdiff) > 1) {
            return -1;
        } else{
            return Math.max(leftheight,rightheight)+1;
        }
    }

2、给定有向图，找出两个节点之间是否存在一条路径
注意：图的遍历广度优先还是深度优先遍历

访问过的节点应该标注为已经访问过，避免重复访问

深度适合搜索（迭代），广度适合查找最短路径

3、使用有序数组构造高度最小的二叉查找树

public TreeNode bst(int[] a,int start,int end) {
        if (end > start) {
            return null;
        }
        int mid = (start+end) /2;
        TreeNode node = new TreeNode(a[mid]);
        node.left = bst(a,start,mid - 1);
        node.right = bst(a,mid+1,end);
        return node;
    }
    public TreeNode createBst(int[] a){
        return bst(a,0,a.length - 1);
    }
4、


5、检查一个二叉树是否为二叉查找树



6、找出一个二叉查找树中指定节点的“下一个节点”（也就是中序后继）。可以假定每个节点都含有指向其父节点的链接

7、找出公共最低祖先



8、子树问题



9、路径和等于某一个target的所以路径























二叉树常见操作以及概念总结

如何确定一个节点root是叶子节点
root.left == null && root.right == null

Binary Tree Preorder Traversal先序遍历（递归实现和非递归实现）
非递归思路：借助于一个栈
Version 0: Non-Recursion (Recommend)/**
* Definition for binary tree
* public class TreeNode {
*    int val;
*    TreeNode left;
*    TreeNode right;
*    TreeNode(int x) { val = x; }
* }
*/public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> preorder = new ArrayList<Integer>();
       
        if (root == null) {
            return preorder;
        }
       
        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            preorder.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
       
        return preorder;
    }}

//Version 1: Traverse
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        traverse(root, result);
        return result;
    }
    // 把root为跟的preorder加入result里面
    private void traverse(TreeNode root, ArrayList<Integer> result) {
        if (root == null) {
            return;
        }

        result.add(root.val);
        traverse(root.left, result);
        traverse(root.right, result);
    }}

中序遍历
迭代：
public List<Integer> inorderTraversal2(TreeNode root) {
         List<Integer> list = new ArrayList<Integer>();

         Stack<TreeNode> stack = new Stack<TreeNode>();
         TreeNode cur = root;//可以直接使用root

         while(cur != null || !stack.empty()){
             while(cur != null){
                 stack.add(cur);
                 cur = cur.left;
             }
             cur = stack.pop();
             list.add(cur.val);
             cur = cur.right;
         }

         return list;
     }

递归：
 public static List<Integer> inorderTraversal0(TreeNode root) {
     if (root == null) return res;
     inOrder(root);
        return res;
    }
    public static void inOrder(TreeNode root) {     //中根遍历
          if(root != null) {
                inOrder(root.left);
                res.add(root.val);
                System.out.print(root.val + "--");
                inOrder(root.right);
          }
     }

后续遍历
//Recursivepublic ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();

    if (root == null) {
        return result;
    }

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result; 
}
迭代实现思路1：
//Iterative
public ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode prev = null; // previously traversed node
    TreeNode curr = root;

    if (root == null) {
        return result;
    }

    stack.push(root);
    while (!stack.empty()) {
        curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { // traverse up the tree from the left
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else { // traverse up the tree from the right
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }

    return result;}

迭代实现思路2：在中序遍历的基础上改进，先根节点然后右节点最后左节点，最后整体翻转一次即可
Stack<TreeNode> stack = new Stack<TreeNode>();
        while (!stack.empty() || root != null) {
            while (root != null) {
                stack.push(root);
                res.add(root.val);
                root = root.right;
            }
            root = stack.pop().left;
        }
        Collections.reverse(res);



层序遍历
思路：非递归，借助一个队列实现，每一层通过当前队列的大小来实现
// version 1: BFS
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList result = new ArrayList();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode head = queue.poll();
                level.add(head.val);
                if (head.left != null) {
                    queue.offer(head.left);
                }
                if (head.right != null) {
                    queue.offer(head.right);
                }
            }
            result.add(level);
        }

        return result;
    }}
思路：dfs，一层一层的计算

// version 2:  DFS
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
       
        if (root == null) {
            return results;
        }
       
        int maxLevel = 0;
        while (true) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            dfs(root, level, 0, maxLevel);
            if (level.size() == 0) {
                break;
            }
           
            results.add(level);
            maxLevel++;
        }
       
        return results;
    }
   
    private void dfs(TreeNode root,
                    ArrayList<Integer> level,
                    int curtLevel,
                    int maxLevel) {
        if (root == null || curtLevel > maxLevel) {
            return;
        }
       
        if (curtLevel == maxLevel) {
            level.add(root.val);
            return;
        }
       
        dfs(root.left, level, curtLevel + 1, maxLevel);
        dfs(root.right, level, curtLevel + 1, maxLevel);
    }}


1、树的最小深度（到叶子节点）
二叉树的最小深度为根节点到最近叶子节点的距离。
思路：当某个节点为null时返回最大整数（这样处理主要是为了处理只有一个子节点的节点），当判断是叶子节点时返回1，然后要是非叶子节点递归求他们的最小深度然后加1
public int minDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return getMin(root);
    }
    public int getMin(TreeNode root) {
        if (root == null) {
            return Integer.MAX_VALUE;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        return Math.min(getMin(root.left), getMin(root.right)) + 1;
    }
2、树的最大深度
二叉树的深度为根节点到最远叶子节点的距离。

思路：当遍历的节点为null的时候返回0，然后递归求左右节点的最大深度取较大的那个然后加1
public int maxDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }


3、二叉树中的最大节点

思路：判断根节点和他的左右子节点哪个大，左右节点递归处理即可
public TreeNode maxNode(TreeNode root) {
        // Write your code here
        if (root == null) {
            return null;
        }
        TreeNode maxNode = root;
        TreeNode maxLeftNode = maxNode(root.left);
        TreeNode maxRightNode = maxNode(root.right);
        if (maxLeftNode != null && maxRightNode != null) {
            TreeNode temp = maxLeftNode.val > maxRightNode.val ? maxLeftNode : maxRightNode;
            return root.val > temp.val ? root : temp;
        } else if (maxLeftNode != null && maxRightNode == null) {
            return root.val > maxLeftNode.val ? root : maxLeftNode;
        } else if (maxLeftNode == null && maxRightNode != null) {
            return root.val > maxRightNode.val ? root : maxRightNode;
        } else {
            return root;
        }
    }
法二：最优解
public TreeNode maxNode(TreeNode root) {
        // Write your code here
        if (root == null)
            return root;

        TreeNode left = maxNode(root.left);
        TreeNode right = maxNode(root.right);
        return max(root, max(left, right));
    }

    TreeNode max(TreeNode a, TreeNode b) {
        if (a == null)
            return b;
        if (b == null)
            return a;
        if (a.val > b.val) {
            return a;
        }
        return b;
    }
4、二叉树的所有路径
给一棵二叉树，找出从根节点到叶子节点的所有路径

思路：通过判断一个节点是否为叶子节点，不是的话递归，是的话添加到list中
public List<String> binaryTreePaths(TreeNode root) {
        // Write your code here
        List<String> res = new ArrayList<String>();
        if (root == null) {
            return res;
        }
        path(root, root.val + "", res);
        return res;
    }
    public void path(TreeNode root, String path, List<String> res) {
        if (root != null) {
            if (root.left != null && root.right != null) {
                path(root.left, path + "->" + root.left.val, res);
                path(root.right, path + "->" + root.right.val, res);
            } else if (root.left != null && root.right == null) {
                path(root.left, path + "->" + root.left.val, res);
            } else if (root.left == null && root.right != null) {
                path(root.right,path + "->" + root.right.val, res);
            } else {
                res.add(path);
            }
        }
    }
5、深度复制一个二叉树。
给定一个二叉树，返回一个他的 克隆品 。
//思路：判断一个节点是不是null，不是的话就新建一个节点，新建节点的左右指向原节点左右节点递归的结果，返回新建节点
public TreeNode cloneTree(TreeNode root) {
        // Write your code here
        if (root == null) {
            return null;
        }
        TreeNode clone_tree = new TreeNode(root.val);
        clone_tree.left = cloneTree(root.left);
        clone_tree.right = cloneTree(root.right);
        return clone_tree;
    }
6、给一个排序数组（从小到大），将其转换为一棵高度最小的排序二叉树。（平衡二叉树）

思路：把中间元素作为根节点，然后递归实现（注意点递归时后面的界限为数组的长度）
public TreeNode sortedArrayToBST(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return null;
        }
        return bst(A, 0, A.length);
    }
    public TreeNode bst(int[] a, int start, int end) {
        if (start < end) {
            int mid = start + (end - start) / 2;
            TreeNode node = new TreeNode(a[mid]);
            node.left = bst(a, start, mid);
            node.right = bst(a, mid + 1, end);
            return node;
        } else {
            return null;
        }
    }



 public TreeNode sortedArrayToBST(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return null;
        }
        return helper(A,0,A.length-1);
    }
    public TreeNode helper(int[] A,int left,int right) {
        if (left > right) {
            return null;
        }
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(A[mid]);
        node.left = helper(A,left,mid - 1);
        node.right = helper(A,mid+1,right);
        return node;
    }

给出一个所有元素以升序排序的单链表，将它转换成一棵高度平衡的二分查找树
public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) { 
        // write your code here
        if (head == null) {
            return null;
        }
        return  sort(head, null);
    }

    public TreeNode sort(ListNode head, ListNode tail) {
        if (head == tail) {
            return null;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != tail && fast.next != tail) {
            fast = fast.next.next;
            slow = slow.next;
        }
        TreeNode node = new TreeNode(slow.val);
        node.left = sort(head, slow);
        node.right = sort(slow.next, tail);
        return node;
    }
}



7、将二叉树拆成链表
将一棵二叉树按照前序遍历拆解成为一个假链表。所谓的假链表是说，用二叉树的 right 指针，来表示链表中的 next 指针。

思路：使用一个指针变量来指向当前转化到哪里，借助前序遍历修改指针的指向，需要注意的点是左指针制为null，此外在修改左子节点是先保存右子节点到一个临时变量
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public TreeNode last = null;
    public void flatten(TreeNode root) {
        // write your code here
        if (root == null) {
            return;
        }
        if (last != null) {
            last.left = null;
            last.right = root;
        }
        last = root;
        TreeNode right = root.right;
        flatten(root.left);
        flatten(right);
    }
}
8、 等价二叉树
检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。

思路：首先判断根节点是否一样，然后在判断左子节点和左子节点，右子节点和右子节点
 public boolean isIdentical(TreeNode a, TreeNode b) {
        // Write your code here
        if (a != null && b != null && a.val == b.val) {
            return isIdentical(a.left, b.left) && isIdentical(a.right, b.right);
        } else if (a == null && b == null) {
            return true;
        } else {
            return false;
        }
    }
9、翻转一棵二叉树

思路：类比交换连个数，然后递归左右子树
public void invertBinaryTree(TreeNode root) {
        // write your code here
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertBinaryTree(root.left);
        invertBinaryTree(root.right);
    }
10、二叉树的右侧视图
For example:
Given the following binary tree,

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---


You should return [1, 3, 4].
思路：深度优先遍历，每一层用map存最右边的节点值（同一层的左节点值会被右节点值覆盖掉），然后在map中每一层去处一个值即可
public class Solution {
    private void dfs(HashMap<Integer, Integer> depthToValue, TreeNode node, int depth) {
        if (node == null) {
            return;
        }
       
        depthToValue.put(depth, node.val);
        dfs(depthToValue, node.left, depth + 1);
        dfs(depthToValue, node.right, depth + 1);
    }
   
    public List<Integer> rightSideView(TreeNode root) {
        HashMap<Integer, Integer> depthToValue = new HashMap<Integer, Integer>();
        dfs(depthToValue, root, 1);
       
        int depth = 1;
        List<Integer> result = new ArrayList<Integer>();
        while (depthToValue.containsKey(depth)) {
            result.add(depthToValue.get(depth));
            depth++;
        }
        return result;
    }}
11、二叉搜索树中添加一个元素（递归和非递归），插入的元素一定是叶子节点？？

思路非递归：使用一个指针指向要插入节点，然后判断插入左还是右边即可
public class Solution {
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        TreeNode tmp = root;
        TreeNode last = null;
        while (tmp != null) {
            last = tmp;
            if (tmp.val > node.val) {
                tmp = tmp.left;
            } else {
                tmp = tmp.right;
            }
        }
        if (last != null) {
            if (last.val > node.val) {
                last.left = node;
            } else {
                last.right = node;
            }
        }
        return root;
    }}


思路：递归实现，判断插入的值和根节点的大小
 public class Solution {
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        if (root.val > node.val) {
            root.left = insertNode(root.left, node);
        } else {
            root.right = insertNode(root.right, node);
        }
        return root;
    }}

二叉搜索树中删除一个节点（有待处理）
给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是二叉查找树。

思路：
public class Solution {
    /**
    * @param root: The root of the binary search tree.
    * @param value: Remove the node with given value.
    * @return: The root of the binary search tree after removal.
    */
    public TreeNode removeNode(TreeNode root, int value) {
        TreeNode dummy = new TreeNode(0);
        dummy.left = root;
       
        TreeNode parent = findNode(dummy, root, value);
        TreeNode node;
        if (parent.left != null && parent.left.val == value) {
            node = parent.left;
        } else if (parent.right != null && parent.right.val == value) {
            node = parent.right;
        } else {
     //直接返回，没有找到节点
            return dummy.left;
        }
       
        deleteNode(parent, node);
       
        return dummy.left;
    }
    //获取指定节点的父节点
    private TreeNode findNode(TreeNode parent, TreeNode node, int value) {
        if (node == null) {
            return parent;
        }
       
        if (node.val == value) {
            return parent;
        }
        if (value < node.val) {
            return findNode(node, node.left, value);
        } else {
            return findNode(node, node.right, value);
        }
    }
   
  private static void deleteNode(TreeNode parent, TreeNode node) {
  //只有左节点，或者叶子节点
  if (node.right == null) {
  if (parent.left == node) {
  parent.left = node.left;
  } else {
  parent.right = node.left;
  }
  } else {
  //找删除节点的后继节点，该节点只有右子树
  TreeNode temp = node.right;
  TreeNode father = node;

  while (temp.left != null) {
  father = temp;
  temp = temp.left;
  }

  if (father.left == temp) {
  father.left = temp.right;
  } else {
  father.right = temp.right;
  }

  //被删除节点的父节点指向删除节点的后继节点，后继节点指向被删除节点的左右节点
  if (parent.left == node) {
  parent.left = temp;
  } else {
  parent.right = temp;
  }

  temp.left = node.left;
  temp.right = node.right;
  }
  }


12、二叉树的序列化和反序列化
序列化：思路借助一个数组，把树的所有元素装入数组，然后清除数组最后都是null的元素，然后遍历数组，为null的用一个字符#代替
反序列化：思路，首先把元素放入第一个数组，然后遍历；把生成的节点放入第二个数组，好用它来指向它的子节点，借助一个Boolean类型的变量来判断是左子节点还是右子节点，要是右子节点，第二个数组的下标后移一位

class Solution {
   
    public String serialize(TreeNode root) {
        if (root == null) {
            return "{}";
        }

        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        queue.add(root);

        for (int i = 0; i < queue.size(); i++) {
            TreeNode node = queue.get(i);
            if (node == null) {
                continue;
            }
            queue.add(node.left);
            queue.add(node.right);
        }

        while (queue.get(queue.size() - 1) == null) {
            queue.remove(queue.size() - 1);
        }

        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append(queue.get(0).val);
        for (int i = 1; i < queue.size(); i++) {
            if (queue.get(i) == null) {
                sb.append(",#");
            } else {
                sb.append(",");
                sb.append(queue.get(i).val);
            }
        }
        sb.append("}");
        return sb.toString();
    }
   
   
    public TreeNode deserialize(String data) {
        if (data.equals("{}")) {
            return null;
        }
        String[] vals = data.substring(1, data.length() - 1).split(",");
        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        queue.add(root);
        int index = 0;
        boolean isLeftChild = true;
        for (int i = 1; i < vals.length; i++) {
            if (!vals[i].equals("#")) {
                TreeNode node = new TreeNode(Integer.parseInt(vals[i]));
                if (isLeftChild) {
                    queue.get(index).left = node;
                } else {
                    queue.get(index).right = node;
                }
                queue.add(node);
            }
            if (!isLeftChild) {
                index++;
            }
            isLeftChild = !isLeftChild;
        }
        return root;
    }}
13、设计实现一个带有下列属性的二叉查找树的迭代器：

	* 元素按照递增的顺序被访问（比如中序遍历）
	* next()和hasNext()的询问操作要求均摊时间复杂度是O(1)

思路：中序遍历的思想，全局维护一个栈和当前游标

public class BSTIterator {
    private Stack<TreeNode> stack = new Stack<>();
    private TreeNode curt;
   
    // @param root: The root of binary tree.
    public BSTIterator(TreeNode root) {
        curt = root;
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return (curt != null || !stack.isEmpty());
    }
   
    //@return: return next node
    public TreeNode next() {
        while (curt != null) {
            stack.push(curt);
            curt = curt.left;
        }
       
        curt = stack.pop();
        TreeNode node = curt;
        curt = curt.right;
       
        return node;
    }}
14、树的节点个数

- /**
-      * 求二叉树中的节点个数递归解法： O(n)
-      * （1）如果二叉树为空，节点个数为0
-      * （2）如果二叉树不为空，二叉树节点个数 = 左子树节点个数 +
-      *            右子树节点个数 + 1
-      */
-     public static int getNodeNumRec(TreeNode root) {
-         if (root == null) {
-             return 0;
-         } else {
-             return getNodeNumRec(root.left) + getNodeNumRec(root.right) + 1;
-         }
-     }
-
-     /**
-      *  求二叉树中的节点个数迭代解法O(n)：基本思想同LevelOrderTraversal，
-      *  即用一个Queue，在Java里面可以用LinkedList来模拟
-      */
-     public static int getNodeNum(TreeNode root) {
-         if(root == null){
-             return 0;
-         }
-         int count = 1;
-         Queue<TreeNode> queue = new LinkedList<TreeNode>();
-         queue.add(root);
-
-         while(!queue.isEmpty()){
-             TreeNode cur = queue.remove();      // 从队头位置移除
-             if(cur.left != null){           // 如果有左孩子，加到队尾
-                 queue.add(cur.left);
-                 count++;
-             }
-             if(cur.right != null){      // 如果有右孩子，加到队尾
-                 queue.add(cur.right);
-                 count++;
-             }
-         }
-
-         return count;
-     }
15、Binary Tree Maximum Path Sum（没理解法二好一些）
计算树的最长path有2种情况：

1. 通过根的path.

  (1)如果左子树从左树根到任何一个Node的path大于零，可以链到root上

  (2)如果右子树从右树根到任何一个Node的path大于零，可以链到root上

2. 不通过根的path. 这个可以取左子树及右子树的path的最大值。

所以创建一个inner class:

记录2个值：

1. 本树的最大path。

2. 本树从根节点出发到任何一个节点的最大path.

Given a binary tree, find the maximum path sum. 
The path may start and end at any node in the tree. 

For example: 
Given the below binary tree, 
  1 
 /  \ 
2   3 
Return 6.
public class Solution {
    private class ResultType {
        // singlePath: 从root往下走到任意点的最大路径，这条路径可以不包含任何点
        // maxPath: 从树中任意到任意点的最大路径，这条路径至少包含一个点
        int singlePath, maxPath;
        ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }

    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(0, Integer.MIN_VALUE);
        }
        // Divide
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // Conquer
        int singlePath = Math.max(left.singlePath, right.singlePath) + root.val;
        singlePath = Math.max(singlePath, 0);

        int maxPath = Math.max(left.maxPath, right.maxPath);
        maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val);

        return new ResultType(singlePath, maxPath);
    }

    public int maxPathSum(TreeNode root) {
        ResultType result = helper(root);
        return result.maxPath;
    }}


// Version 2:// SinglePath也定义为，至少包含一个点。public class Solution {
    /**
    * @param root: The root of binary tree.
    * @return: An integer.
    */
    private class ResultType {
        int singlePath, maxPath;
        ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }

    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(Integer.MIN_VALUE, Integer.MIN_VALUE);
        }
        // Divide
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // Conquer
        int singlePath =
            Math.max(0, Math.max(left.singlePath, right.singlePath)) + root.val;

        int maxPath = Math.max(left.maxPath, right.maxPath);
        maxPath = Math.max(maxPath,
                          Math.max(left.singlePath, 0) +
                          Math.max(right.singlePath, 0) + root.val);

        return new ResultType(singlePath, maxPath);
    }

    public int maxPathSum(TreeNode root) {
        ResultType result = helper(root);
        return result.maxPath;
    }

}
16、给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode A, TreeNode B) {
        // write your code here
        if (root == null || root == A || root == B) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, A, B);
        TreeNode right = lowestCommonAncestor(root.right, A, B);
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        } else {
            return null;
        }
    }

17、判断子树
public boolean isSubtree(TreeNode T1, TreeNode T2) {
        // write your code here
        boolean res = false;
        if (T2 == null) {
            return true;
        }
        if (T1 == null) {
            return false;
        }
        if (T1.val == T2.val) {
            res = tree1HasTree2(T1,T2);
        }
        if(!res) {
            res = isSubtree(T1.left,T2);
        }
        if(!res) {
            res = isSubtree(T1.right,T2);
        }
        return res;
    }
    public boolean tree1HasTree2(TreeNode T1, TreeNode T2) {
        if (T1 == null && T2 == null) {
            return true;
        }
        if (T1 != null && T2 != null && T1.val == T2.val) {
            return tree1HasTree2(T1.left,T2.left) && tree1HasTree2(T1.right,T2.right);
        }
        return false;
    }

18\路径和
public static List<List<Integer>> binaryTreePathSum(TreeNode root, int target) {
             List<List<Integer>> res = new ArrayList<List<Integer>>();
             if (root==null) {
                 return res;
             }
             List<Integer> path = new ArrayList<Integer>();
             path.add(root.value);
             helper(res,path,root,target,root.value);
             return res;
  }


  public static void helper( List<List<Integer>> res,List<Integer> path,TreeNode root,int target,int sum) {
             if (root.left == null && root.right == null && sum == target) {
                 res.add( new ArrayList<Integer>(path));
                 return;
             }
             if (root.left != null) {
                 path.add(root.left.value);
                 helper(res,path,root.left,target,sum + root.left.value);
                 path.remove(path.size() - 1);
             }
             if (root.right != null) {
                 path.add(root.right.value);
                 helper(res,path,root.right,target,sum + root.right.value);
                 path.remove(path.size() - 1);
             }
  }


//求出二叉树的所有路径
public static List<List<Integer>> binaryTreePathSum(TreeNode root, int target) {
        // Write your code here
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (root == null) {
            return res;
        }
        List<Integer> path = new ArrayList<Integer>();
        path.add(root.val);
        helper(res,path,root);
        System.out.println(res);
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        for (int i = 0;i < res.size();i++) {
            List<Integer> temp = res.get(i);
            int sum = 0;
            for (int j = 0;j < temp.size();j++ ) {
                sum += temp.get(j);
            }
            if (sum == target) {
                result.add(temp);
            }
        }
        return result;
    }
    public static void  helper(List<List<Integer>> res,List<Integer> list,TreeNode root) {
        if (root.left == null && root.right == null) {
            res.add(new ArrayList<Integer>(list));
            return;
        }
        if (root.left != null) {
            list.add(root.left.val);
            helper(res,list,root.left);
            list.remove(list.size() - 1);
        }
        if (root.right != null) {
            list.add(root.right.val);
            helper(res,list,root.right);
            list.remove(list.size() - 1);
        }
    }
