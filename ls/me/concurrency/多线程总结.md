---
title: 多线程总结
categories: 
- concurrent
tags:

---

# 多进程和多线程出现的原因
资源利用率、公平性、便利性

# 多线程的优势
发挥多处理器的强大能力、建模的简单性、异步事件的简化处理、响应更灵敏的用户界面

# 多线程带来的风险
安全性问题：在没有足够同步的情况下，多线程中的操作执行顺序是不可预测的，甚至会出现奇怪的结果。
活跃性问题：“正确的事情最终会发生” ，就是死锁、饥饿、活锁等
性能问题：线程切换的开销、当使用同步机制会抑制某些编译器的优化，使得内存缓冲区中的数据无效


# 进程和线程的区别

进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
在早期面向进程设计的计算机结构中，进程是程序的基本执行实体;在当代面向线程设计的计算机结构中，进程是线程的容器。
程序是指令、数据及其组织形式的描述，进程是程序的实体。---百科

线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。
另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，
但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。
由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，
逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。
每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。
在单个程序中同时运行多个线程完成不同的工作，称为多线程。 ---百科

进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
线程：同一类线程（一个进程内）共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
多进程是指操作系统能同时运行多个任务（程序）。
多线程是指在同一程序中有多个顺序流在执行。


# 进程间通信 IPC，Inter-Process Communication
管道、命名管道、信号、信号量、共享内存、内存映射、文件、消息队列、套接字socket


# 线程安全性（对共享的和可变的状态访问）
1、线程安全性（核心正确性）
当多个线程访问某个类时，这个类始终都能够表现出正确的行为，那么就称之为这个类是线程安全的。
注释：无状态的对象一定是线程安全的

2、操作的原子性---不可分割的单元
在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种重要的情况，叫做竞态条件
竞态条件的本质是基于一种可能失效的观察结果来做出判断或者执行某个计算。

内置锁或者监视锁（同步代码块synchronized）
synchronized（lock） {
。。。。
}
同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块

锁的重入性：如果某个线程试图获得一个由它自己持有的锁，如果这个请求成功，那么这个锁具有重入性（内置锁具有重入性）；
重入的一种实现方式：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时表示锁没有被任何线程持有。当线程请求一个未被持有的锁时，jvm记下锁的持有者并将获取计数值制为1.如果同一个线程再次获取这个锁，计数值递增，而当线程退出同步代码块时，计数器递减。当计数值减为0时，这个锁将被释放。
锁的重入性可以解决当子类改写父类的synchronized方法，然后调用父类中的方法造成的死锁问题。

注释：一般情况下，当一个线程请求一个正在被其他线程持有的锁时，发出请求的线程就会被阻塞。

3、使用锁synchronized来保护状态  

# 对象的共享（不安全的情况其实是共享且可变）

1、内存可见性
 
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

最低安全性适合于绝大多数的变量，非volatile类型的64位数值变量（long，double）

加锁的行为不仅是实现互斥还包括内存可见性。为了确保所有的线程都能够看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步。

volatile变量：（访问不加锁）
作用：用来确保变量的更新操作通知到其他线程。
当变量声明为volatile类型后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volitale变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volitale类型的变量时总会返回最新写入的值。

volatile变量的通常用法：做为某个操作完成、发生中断或者状态的标志。

满足一下条件才可以使用volitale
a、对变量的写操作不依赖于变量的当前值，或者你能确保只有单个线程更新变量的值
b、该变量不会与其他状态变量一起纳入不可变条件中
c、在访问变量时不需要加锁。

2、发布和逸出



3、线程封闭 

一种避免同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。
局部变量和ThreadLocal类

栈封闭其实就是局部变量，一个方法在运行的时候开启一个栈，将变量封装在栈中。

ThreadLocal对象常用于防止对可变的单实例变量或者全局变量进行共享。

4、不变性

不可变对象一定是线程安全的

不可变对象的满足条件：
a、对象创建以后其状态不能修改
b、对象的所有域都是final类型
c、对象是正确创建的（在创建期间，this引用没有逸出）

正如“除非需要更高的可见性，否则应将所有域都声明为私有域”，同样，“除非需要某个域是可变的，否者应将其声明为final域”

使用volitale类型来发布不可变对象实现线程的安全

5、安全发布

常用的安全发布对象的模式：安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。
a、在静态初始化函数中初始化一个对象的引用；（例如单例模式的懒汉模式）
b、将对象的引用保存到volatile类型或者atomicreference对象中
c、将对象的引用保存到某个正确构造对象的final类型域中；
d、将对象的引用保存到一个由锁保护的域中；（例如安全容器）

对象的发布需求取决于它的可变性
a、不可变对象可以通过任意机制来发布；
b、事实不可变对象必须通过安全方式来发布；
c、可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁来保护起来；

并发线程使用共享对象的一些实用策略：
a、线程封闭
b、只读共享（不可变对象和事实不可变对象）
c、线程安全共享（？？？）
d、保护对象（锁机制）







# 多线程的优缺点

## 多线程的优点
1）资源利用率更好
2）程序设计在某些情况下更简单
3）程序响应更快

## 多线程的缺点

1）设计更复杂
虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。
线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。

2）上下文切换的开销
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，
程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，
然后切换到另外一个上下文中执行另外一个线程。上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。
